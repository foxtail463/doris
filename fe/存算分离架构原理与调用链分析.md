# Doris 存算分离架构原理与调用链分析

## 目录
1. [架构概述](#架构概述)
2. [核心组件](#核心组件)
3. [关键调用链](#关键调用链)
   - [1. 查询调用链：从SQL到数据读取](#1-查询调用链从sql到数据读取)
   - [2. Tablet创建调用链：从建表到Tablet分配](#2-tablet创建调用链从建表到tablet分配)
   - [3. Tablet重平衡调用链](#3-tablet重平衡调用链)
   - [4. 计算组选择调用链](#4-计算组选择调用链)
   - [5. 数据写入调用链（存算分离模式）](#5-数据写入调用链存算分离模式)
   - [6. BE端数据读取调用链（存算分离模式）](#6-be端数据读取调用链存算分离模式)
   - [7. 调用链关键点总结](#7-调用链关键点总结)
4. [数据流程](#数据流程)
5. [配置说明](#配置说明)
6. [调用链快速参考表](#调用链快速参考表)
7. [调试建议](#调试建议)

---

## 架构概述

存算分离架构将存储和计算解耦，实现以下核心特性：

- **存储层**：数据存储在对象存储（S3/HDFS等）中，通过 `StorageVault` 统一管理
- **计算层**：计算节点（Backend）通过 `ComputeGroup` 组织，负责查询和计算
- **元数据层**：通过 Meta Service 统一管理元数据
- **动态映射**：Tablet 不固定绑定到特定 BE，而是根据 ComputeGroup 动态映射

### 架构对比

| 特性 | 存算一体 | 存算分离 |
|------|---------|---------|
| 数据存储 | BE本地磁盘 | 对象存储（S3/HDFS） |
| Tablet绑定 | 固定绑定到BE | 动态映射到BE |
| 扩缩容 | 需要数据迁移 | 计算节点独立扩缩容 |
| 成本优化 | 计算存储耦合 | 计算节点可自动启停 |

---

## 核心组件

### 1. ComputeGroup（计算组）

**位置**：`fe-core/src/main/java/org/apache/doris/cloud/catalog/ComputeGroup.java`

**核心职责**：
- 组织和管理计算节点（Backend）
- 支持主备策略（ActiveStandby）
- 支持自动启停功能
- 配置预热策略

**关键属性**：
```java
private String id;                    // 计算组ID
private String name;                  // 计算组名称
private ComputeTypeEnum type;         // 类型：SQL/COMPUTE/VIRTUAL
private Policy policy;                 // 主备策略
private Map<String, String> properties; // 属性配置（balance_type等）
```

**关键方法**：
- `getBalanceType()`: 获取平衡类型（without_warmup/async_warmup/sync_warmup）
- `getBalanceWarmUpTaskTimeout()`: 获取预热任务超时时间

### 2. StorageVault（存储仓库）

**位置**：`fe-core/src/main/java/org/apache/doris/catalog/StorageVault.java`

**核心职责**：
- 管理存储后端（S3、HDFS等）
- 提供统一的存储访问接口
- 支持多存储后端

**支持的存储类型**：
- S3（Amazon S3）
- HDFS（Hadoop Distributed File System）

### 3. CloudReplica（云副本）

**位置**：`fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java`

**核心职责**：
- 实现动态BE映射（不固定绑定到特定BE）
- 支持多计算组映射
- 通过Hash算法选择BE

**关键数据结构**：
```java
// 主计算组到BE的映射
private Map<String, List<Long>> primaryClusterToBackends;

// 内存计算组到BE的映射（多副本模式）
private Map<String, List<Long>> memClusterToBackends;

// 备用BE映射（非立即分配模式）
private Map<String, Pair<Long, Long>> secondaryClusterToBackends;
```

### 4. CloudTabletRebalancer（Tablet重平衡器）

**位置**：`fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudTabletRebalancer.java`

**核心职责**：
- 在计算节点间平衡Tablet分布
- 支持分区级、表级、全局三级平衡
- 支持平滑升级时的Tablet迁移
- 支持预热策略

### 5. CloudSystemInfoService（云系统信息服务）

**位置**：`fe-core/src/main/java/org/apache/doris/cloud/system/CloudSystemInfoService.java`

**核心职责**：
- 管理计算组和Backend的映射关系
- 提供计算组查询接口
- 处理计算组的增删改查

**关键数据结构**：
```java
// clusterId -> List<Backend>
protected Map<String, List<Backend>> clusterIdToBackend;

// clusterName -> clusterId
protected Map<String, String> clusterNameToId;

// clusterId -> ComputeGroup
protected Map<String, ComputeGroup> computeGroupIdToComputeGroup;
```

---

## 关键调用链

### 1. 查询调用链：从SQL到数据读取

#### 1.1 完整调用链路

```
SQL查询请求
    ↓
ConnectContext.getComputeGroup()  // 获取计算组
    ↓
OlapScanNode.addScanRangeLocations()  // 添加扫描范围
    ↓
Tablet.getQueryableReplicas()  // 获取可查询副本
    ↓
CloudReplica.getBackendId()  // 【关键】动态获取BE ID
    ↓
CloudReplica.getBackendIdImpl()  // 实现动态映射
    ↓
CloudReplica.hashReplicaToBe()  // Hash选择BE
    ↓
CloudSystemInfoService.getBackendsByClusterId()  // 获取计算组的BE列表
    ↓
返回Backend ID
    ↓
构建TScanRangeLocation
    ↓
发送到BE执行查询
    ↓
BE从对象存储读取数据
```

#### 1.2 关键代码调用链（带代码位置）

**步骤1：获取计算组**
```java
// 文件：fe-core/src/main/java/org/apache/doris/planner/OlapScanNode.java
// 行号：441-457
private void addScanRangeLocations(Partition partition,
        List<Tablet> tablets, Map<Long, Set<Long>> backendAlivePathHashs) throws UserException {
    ConnectContext context = ConnectContext.get();
    ComputeGroup computeGroup = null;
    if (context != null) {
        computeGroup = context.getComputeGroupSafely();  // 【关键】获取计算组
        // ...
    }
    // ...
}
```

**步骤2：遍历Tablet获取副本**
```java
// 文件：fe-core/src/main/java/org/apache/doris/planner/OlapScanNode.java
// 行号：476-658
for (Tablet tablet : tablets) {
    // 获取可查询的副本
    List<Replica> replicas = tablet.getQueryableReplicas(
        visibleVersion, backendAlivePathHashs, skipMissingVersion);
    
    for (Replica replica : replicas) {
        // 【关键调用】动态获取BE ID（存算分离的核心）
        long backendId = replica.getBackendId();
        
        Backend backend = Env.getCurrentSystemInfo().getBackend(backendId);
        String ip = backend.getHost();
        int port = backend.getBePort();
        TNetworkAddress networkAddress = new TNetworkAddress(ip, port);
        TScanRangeLocation scanRangeLocation = new TScanRangeLocation(networkAddress);
        scanRangeLocation.setBackendId(backendId);
        locations.addToLocations(scanRangeLocation);
    }
}
```

**步骤3：CloudReplica动态映射BE（核心逻辑）**
```java
// 文件：fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java
// 行号：159-162
@Override
public long getBackendId() throws ComputeGroupException {
    return getBackendIdImpl(getCurrentClusterId());
}

// 行号：212-262
private String getCurrentClusterId() throws ComputeGroupException {
    ConnectContext context = ConnectContext.get();
    if (context != null) {
        // 从连接上下文获取集群名称
        String cluster = ((CloudSystemInfoService) Env.getCurrentSystemInfo())
                .getPhysicalCluster(context.getCloudCluster());
        
        // 检查用户权限
        UserIdentity currentUid = context.getCurrentUserIdentity();
        if (currentUid != null && !StringUtils.isEmpty(currentUid.getQualifiedUser())) {
            ((CloudEnv) Env.getCurrentEnv()).checkCloudClusterPriv(cluster);
        }
        
        // 检查集群状态
        String clusterStatus = ((CloudSystemInfoService) Env.getCurrentSystemInfo())
                .getCloudStatusByName(cluster);
        if (Cloud.ClusterStatus.valueOf(clusterStatus) == Cloud.ClusterStatus.MANUAL_SHUTDOWN) {
            throw new ComputeGroupException("The current compute group has been manually shutdown");
        }
    }
    
    return getCloudClusterIdByName(cluster);
}
```

**步骤4：实现BE选择逻辑（详细实现）**
```java
// 文件：fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java
// 行号：297-371
private long getBackendIdImpl(String clusterId) throws ComputeGroupException {
    if (Strings.isNullOrEmpty(clusterId)) {
        return -1L;
    }

    // 【场景1】Colocate表：使用Colocate逻辑选择BE
    if (isColocated()) {
        return getColocatedBeId(clusterId);
    }

    // 【场景2】多副本模式
    if (Config.enable_cloud_multi_replica) {
        int indexRand = rand.nextInt(Config.cloud_replica_num);
        int coldReadRand = rand.nextInt(100);
        boolean allowColdRead = coldReadRand < Config.cloud_cold_read_percent;
        boolean replicaEnough = memClusterToBackends.get(clusterId) != null
                && memClusterToBackends.get(clusterId).size() > indexRand;

        long backendId = -1;
        if (replicaEnough) {
            backendId = memClusterToBackends.get(clusterId).get(indexRand);
        }

        if (!replicaEnough && !allowColdRead && primaryClusterToBackends.containsKey(clusterId)) {
            backendId = primaryClusterToBackends.get(clusterId).get(0);
        }

        if (backendId > 0) {
            Backend be = Env.getCurrentSystemInfo().getBackend(backendId);
            if (be != null && be.isQueryAvailable()) {
                return backendId;
            }
        }

        // 重新Hash选择多个BE
        List<Long> res = hashReplicaToBes(clusterId, false, Config.cloud_replica_num);
        if (res.size() < indexRand + 1) {
            return res.isEmpty() ? -1 : res.get(0);
        } else {
            return res.get(indexRand);
        }
    }

    // 【场景3】单副本模式：优先使用primaryClusterToBackends
    Backend be = getPrimaryBackend(clusterId, false);
    if (be != null && be.isQueryAvailable()) {
        return be.getId();
    }

    // 【场景4】如果primary BE不可用，使用secondary BE（延迟分配模式）
    if (!Config.enable_immediate_be_assign) {
        be = getSecondaryBackend(clusterId);
        if (be != null && be.isQueryAvailable()) {
            return be.getId();
        }
    }

    // 【场景5】重新Hash选择BE（BE异常或首次分配）
    long pickBeId = hashReplicaToBe(clusterId, false);
    if (Config.enable_immediate_be_assign) {
        updateClusterToPrimaryBe(clusterId, pickBeId);  // 立即分配模式
    } else {
        updateClusterToSecondaryBe(clusterId, pickBeId);  // 延迟分配模式
    }
    return pickBeId;
}
```

**步骤5：Hash算法选择BE（核心算法）**
```java
// 文件：fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java
// 行号：408-460
public long hashReplicaToBe(String clusterId, boolean isBackGround) throws ComputeGroupException {
    // 1. 获取计算组的所有BE
    List<Backend> clusterBes = ((CloudSystemInfoService) Env.getCurrentSystemInfo())
            .getBackendsByClusterId(clusterId);
    String clusterName = ((CloudSystemInfoService) Env.getCurrentSystemInfo())
            .getClusterNameByClusterId(clusterId);
    
    if (clusterBes.isEmpty()) {
        throw new ComputeGroupException(
            String.format("There are no Backend nodes in the current compute group %s", clusterName),
            ComputeGroupException.FailedTypeEnum.CURRENT_COMPUTE_GROUP_NO_BE);
    }
    
    // 2. 过滤出可用的BE（排除正在平滑升级的BE）
    List<Backend> availableBes = new ArrayList<>();
    List<Backend> decommissionAvailBes = new ArrayList<>();
    for (Backend be : clusterBes) {
        if (be.isQueryAvailable() && !be.isSmoothUpgradeSrc()) {
            if (be.isDecommissioned()) {
                decommissionAvailBes.add(be);
            } else {
                availableBes.add(be);
            }
        }
    }
    if (availableBes.isEmpty()) {
        availableBes = decommissionAvailBes;
    }
    if (availableBes.isEmpty()) {
        throw new ComputeGroupException(
            String.format("All the Backend nodes in the current compute group %s are in an abnormal state",
                clusterName),
            ComputeGroupException.FailedTypeEnum.COMPUTE_GROUPS_NO_ALIVE_BE);
    }
    
    // 3. Hash选择算法
    long index = -1;
    HashCode hashCode = null;
    if (idx == -1) {
        // 如果没有idx，使用replicaId取模
        index = getId() % availableBes.size();
    } else {
        // 使用partitionId + idx进行Hash，保证相同partition的tablet映射一致性
        hashCode = Hashing.murmur3_128().hashLong(partitionId);
        index = getIndexByBeNum(hashCode.asLong() + idx, availableBes.size());
    }
    long pickedBeId = availableBes.get((int) index).getId();
    
    LOG.info("picked clusterName {} beId {}, replicaId {}, partitionId {}, beNum {}, "
            + "replicaIdx {}, picked Index {}, hashVal {}",
            clusterName, pickedBeId, getId(), partitionId, availableBes.size(), idx, index,
            hashCode == null ? -1 : hashCode.asLong());
    
    return pickedBeId;
}

// 行号：462-467
private long getIndexByBeNum(long hashValue, int beNum) {
    // hashValue可能是负数，需要确保结果是正数
    return (hashValue % beNum + beNum) % beNum;
}
```

**步骤6：构建扫描范围并发送到BE**
```java
// 文件：fe-core/src/main/java/org/apache/doris/planner/OlapScanNode.java
// 行号：632-673
String ip = backend.getHost();
int port = backend.getBePort();
TNetworkAddress networkAddress = new TNetworkAddress(ip, port);
TScanRangeLocation scanRangeLocation = new TScanRangeLocation(networkAddress);
scanRangeLocation.setBackendId(backendId);
locations.addToLocations(scanRangeLocation);

// 构建TScanRange
TScanRange scanRange = new TScanRange();
scanRange.setPaloScanRange(paloRange);
locations.setScanRange(scanRange);

// 按bucketSeq分组
Integer bucketSeq = tabletId2BucketSeq.get(tabletId);
bucketSeq2locations.put(bucketSeq, locations);
scanRangeLocations.add(locations);
```

#### 1.3 调用链时序图（详细版）

```
┌────────┐    ┌──────────────────┐    ┌─────────────────────┐    ┌──────────────────────┐    ┌──────────────────────┐
│ Client │    │  OlapScanNode    │    │   CloudReplica      │    │ CloudSystemInfoService│    │   ComputeGroup       │
└───┬────┘    └────────┬─────────┘    └──────────┬──────────┘    └──────────┬───────────┘    └──────────┬───────────┘
    │                  │                          │                          │                            │
    │ SQL查询           │                          │                          │                            │
    ├─────────────────>│                          │                          │                            │
    │                  │                          │                          │                            │
    │                  │ addScanRangeLocations()  │                          │                            │
    │                  │ 获取ComputeGroup          │                          │                            │
    │                  ├─────────────────────────>│                          │                            │
    │                  │                          │                          │                            │
    │                  │                          │                          │ getCloudClusterIdByName() │
    │                  │                          │                          ├──────────────────────────>│
    │                  │                          │                          │<──────────────────────────┤
    │                  │                          │                          │                            │
    │                  │ 遍历Tablets               │                          │                            │
    │                  │                          │                          │                            │
    │                  │ replica.getBackendId()   │                          │                            │
    │                  ├─────────────────────────>│                          │                            │
    │                  │                          │                          │                            │
    │                  │                          │ getBackendIdImpl()        │                            │
    │                  │                          │ 检查映射关系              │                            │
    │                  │                          │                          │                            │
    │                  │                          │ hashReplicaToBe()         │                            │
    │                  │                          ├─────────────────────────>│                            │
    │                  │                          │                          │                            │
    │                  │                          │                          │ getBackendsByClusterId()   │
    │                  │                          │                          ├──────────────────────────>│
    │                  │                          │                          │<──────────────────────────┤
    │                  │                          │                          │ 返回BE列表                 │
    │                  │                          │                          │                            │
    │                  │                          │<─────────────────────────┤                            │
    │                  │                          │ Hash算法选择BE            │                            │
    │                  │                          │                          │                            │
    │                  │<─────────────────────────┤                          │                            │
    │                  │ 返回BackendId            │                          │                            │
    │                  │                          │                          │                            │
    │                  │ 构建TScanRangeLocation    │                          │                            │
    │                  │                          │                          │                            │
    └──────────────────┴──────────────────────────┴──────────────────────────┴────────────────────────────┘

    ┌────────┐    ┌──────────────┐    ┌────────────────────┐
    │   BE   │    │ 对象存储      │    │                    │
    └───┬────┘    └──────┬───────┘    │                    │
        │                │             │                    │
        │ 接收扫描请求     │             │                    │
        │<───────────────│             │                    │
        │                │             │                    │
        │ 从对象存储读取   │             │                    │
        ├───────────────>│             │                    │
        │                │             │                    │
        │<───────────────┤             │                    │
        │ 返回数据        │             │                    │
        │                │             │                    │
```

#### 1.4 关键调用链代码追踪示例

**示例：追踪一次查询的完整调用链**

假设执行查询：`SELECT * FROM table1 WHERE id = 1`

```java
// 1. 入口：OlapScanNode.addScanRangeLocations()
// 文件：fe-core/src/main/java/org/apache/doris/planner/OlapScanNode.java:441
OlapScanNode.addScanRangeLocations(partition, tablets, backendAlivePathHashs)
  ├─> ConnectContext.get()                                    // 获取连接上下文
  ├─> context.getComputeGroupSafely()                        // 获取计算组
  └─> for (Tablet tablet : tablets) {                        // 遍历Tablet
        ├─> tablet.getQueryableReplicas(...)                 // 获取可查询副本
        └─> for (Replica replica : replicas) {
              └─> replica.getBackendId()                     // 【关键调用】动态获取BE ID

// 2. 核心：CloudReplica.getBackendId()
// 文件：fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java:160
CloudReplica.getBackendId()
  └─> getBackendIdImpl(getCurrentClusterId())                // 获取集群ID并调用实现

// 3. 获取集群ID
// 文件：fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java:212
getCurrentClusterId()
  ├─> ConnectContext.get()                                   // 从上下文获取
  ├─> CloudSystemInfoService.getPhysicalCluster(...)        // 获取物理集群名称
  ├─> checkCloudClusterPriv(cluster)                        // 检查权限
  └─> getCloudClusterIdByName(cluster)                      // 获取集群ID

// 4. BE选择实现
// 文件：fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java:297
getBackendIdImpl(clusterId)
  ├─> if (isColocated()) return getColocatedBeId(...)       // Colocate表逻辑
  ├─> if (enable_cloud_multi_replica) { ... }               // 多副本模式
  ├─> getPrimaryBackend(clusterId, false)                   // 尝试获取主BE
  ├─> if (!enable_immediate_be_assign)                      // 延迟分配模式
  │     getSecondaryBackend(clusterId)                      // 尝试获取备用BE
  └─> hashReplicaToBe(clusterId, false)                     // Hash选择BE

// 5. Hash算法
// 文件：fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java:408
hashReplicaToBe(clusterId, isBackGround)
  ├─> CloudSystemInfoService.getBackendsByClusterId(clusterId) // 获取BE列表
  ├─> filterAvailableBackends(clusterBes)                   // 过滤可用BE
  ├─> Hashing.murmur3_128().hashLong(partitionId)          // Hash计算
  └─> getIndexByBeNum(hashCode.asLong() + idx, beNum)      // 计算索引

// 6. 返回并构建扫描范围
// 文件：fe-core/src/main/java/org/apache/doris/planner/OlapScanNode.java:632
  ├─> new TScanRangeLocation(networkAddress)
  ├─> scanRangeLocation.setBackendId(backendId)
  └─> locations.addToLocations(scanRangeLocation)
```

---

### 2. Tablet创建调用链：从建表到Tablet分配

#### 2.1 完整调用链路

```
CREATE TABLE 语句
    ↓
CloudInternalCatalog.createCloudTablets()  // 创建Tablet
    ↓
创建CloudReplica（不指定BE ID）
    ↓
Tablet.addReplica()  // 添加副本到Tablet
    ↓
【存算分离特点】Replica不绑定BE，backendId = -1
    ↓
查询时动态映射到BE
```

#### 2.2 关键代码调用链

**步骤1：创建Tablet和Replica**
```java
// CloudInternalCatalog.createCloudTablets()
private void createCloudTablets(MaterializedIndex index, ReplicaState replicaState,
        DistributionInfo distributionInfo, long version, ReplicaAllocation replicaAlloc,
        TabletMeta tabletMeta, Set<Long> tabletIdSet) throws DdlException {
    
    for (int i = 0; i < distributionInfo.getBucketNum(); ++i) {
        // 1. 创建Tablet
        Tablet tablet = EnvFactory.getInstance().createTablet(
            Env.getCurrentEnv().getNextId());
        
        // 2. 添加到索引
        index.addTablet(tablet, tabletMeta);
        tabletIdSet.add(tablet.getId());
        
        // 3. 创建CloudReplica（注意：backendId = null）
        long replicaId = Env.getCurrentEnv().getNextId();
        Replica replica = new CloudReplica(replicaId, null, replicaState, version,
                tabletMeta.getOldSchemaHash(), tabletMeta.getDbId(), 
                tabletMeta.getTableId(), tabletMeta.getPartitionId(), 
                tabletMeta.getIndexId(), i);
        
        // 4. 添加副本（此时不绑定BE）
        tablet.addReplica(replica);
    }
}
```

**步骤2：CloudReplica构造函数**
```java
// CloudReplica构造函数
public CloudReplica(long replicaId, Long backendId, ReplicaState state, 
        long version, int schemaHash, long dbId, long tableId, 
        long partitionId, long indexId, long idx) {
    // 注意：backendId传入null，调用super时传入-1
    super(replicaId, -1, state, version, schemaHash);
    this.dbId = dbId;
    this.tableId = tableId;
    this.partitionId = partitionId;
    this.indexId = indexId;
    this.idx = idx;
    // primaryClusterToBackends初始化为空，等待查询时动态映射
}
```

**对比：存算一体模式的Tablet创建**
```java
// InternalCatalog.createTablets() - 存算一体模式
// 在创建时就需要选择BE并绑定
List<Long> chosenBackendIds = selectBackendIds(...);
for (Long backendId : chosenBackendIds) {
    Replica replica = new Replica(replicaId, backendId, ...);
    tablet.addReplica(replica);
}
```

---

### 3. Tablet重平衡调用链

#### 3.1 完整调用链路

```
CloudTabletRebalancer.runAfterCatalogReady()  // 定时任务触发
    ↓
统计BE到Tablet的映射关系
    ↓
计算平衡度（分区级/表级/全局）
    ↓
选择需要迁移的Tablet
    ↓
CloudReplica.updateClusterToPrimaryBe()  // 更新映射关系
    ↓
发送预热任务到BE（如果启用预热）
    ↓
等待预热完成
    ↓
更新元数据
```

#### 3.2 关键代码调用链

**步骤1：重平衡主流程**
```java
// CloudTabletRebalancer.runAfterCatalogReady()
@Override
protected void runAfterCatalogReady() {
    // 1. 构建cluster到BE的映射
    buildClusterToBeMap();
    
    // 2. 统计BE到Tablet的映射
    statisticsBeToTablets();
    
    // 3. 分区级平衡
    if (!indexBalanced) {
        balancePartitionLevel();
    }
    
    // 4. 表级平衡（如果分区级已平衡）
    if (indexBalanced && !tableBalanced) {
        balanceTableLevel();
    }
    
    // 5. 全局平衡（如果分区级和表级都已平衡）
    if (indexBalanced && tableBalanced) {
        balanceGlobal();
    }
}
```

**步骤2：选择需要迁移的Tablet**
```java
// CloudTabletRebalancer.balanceGlobal()
private void balanceGlobal() {
    // 1. 计算每个BE的Tablet数量
    Map<Long, Integer> beToTabletCount = calculateTabletCount();
    
    // 2. 找出Tablet数量最多的BE（srcBe）和最少的BE（destBe）
    TransferPairInfo pair = findTransferPair(beToTabletCount);
    
    // 3. 从srcBe选择Tablet迁移到destBe
    Tablet pickedTablet = selectTabletToMigrate(pair.srcBe);
    
    // 4. 更新映射关系
    updateTabletMapping(pickedTablet, pair.srcBe, pair.destBe);
}
```

**步骤3：更新Tablet映射**
```java
// CloudTabletRebalancer.updateTabletMapping()
private void updateTabletMapping(Tablet tablet, long srcBe, long destBe, 
        String clusterId) {
    CloudReplica replica = (CloudReplica) tablet.getReplicas().get(0);
    
    // 更新CloudReplica的映射关系
    replica.updateClusterToPrimaryBe(clusterId, destBe);
    
    // 更新重平衡器的统计信息
    beToTabletsGlobal.get(srcBe).remove(tablet);
    beToTabletsGlobal.get(destBe).add(tablet);
    
    // 发送预热任务（如果启用预热）
    if (getCurrentBalanceType(clusterId) != BalanceTypeEnum.WITHOUT_WARMUP) {
        sendWarmUpTask(tablet, destBe, clusterId);
    }
}
```

**步骤4：CloudReplica更新映射**
```java
// CloudReplica.updateClusterToPrimaryBe()
public void updateClusterToPrimaryBe(String cluster, long beId) {
    // 更新主映射
    primaryClusterToBackends.put(cluster, Lists.newArrayList(beId));
    
    // 清除备用映射
    secondaryClusterToBackends.remove(cluster);
}
```

---

### 4. 计算组选择调用链

#### 4.1 完整调用链路

```
用户连接/查询请求
    ↓
ConnectContext.getComputeGroup()  // 获取计算组
    ↓
ComputeGroupMgr.getComputeGroup()  // 从管理器获取
    ↓
CloudSystemInfoService.getCloudClusterIdByName()  // 获取clusterId
    ↓
CloudSystemInfoService.getBackendsByClusterId()  // 获取BE列表
    ↓
返回ComputeGroup对象
```

#### 4.2 关键代码调用链

**步骤1：从ConnectContext获取计算组**
```java
// ConnectContext.getComputeGroup()
public ComputeGroup getComputeGroup() {
    if (computeGroup == null) {
        computeGroup = Env.getCurrentEnv().getComputeGroupMgr()
                .getComputeGroup(getResourceTags());
    }
    return computeGroup;
}
```

**步骤2：ComputeGroupMgr获取计算组**
```java
// ComputeGroupMgr.getComputeGroupByName()
public ComputeGroup getComputeGroupByName(String name) throws UserException {
    if (Config.isCloudMode()) {
        CloudSystemInfoService cloudSystemInfoService = 
            (CloudSystemInfoService) systemInfoService;
        
        // 获取物理集群名称
        String physicalClusterName = 
            ((CloudSystemInfoService) Env.getCurrentSystemInfo())
                .getPhysicalCluster(name);
        
        // 获取clusterId
        String clusterId = cloudSystemInfoService.getCloudClusterIdByName(
            physicalClusterName);
        
        if (StringUtils.isEmpty(clusterId)) {
            throw new UserException("Compute group not found: " + physicalClusterName);
        }
        
        // 创建CloudComputeGroup
        return new CloudComputeGroup(clusterId, physicalClusterName, 
            cloudSystemInfoService);
    } else {
        // 非云模式
        return new ComputeGroup(name, name, systemInfoService);
    }
}
```

**步骤3：CloudSystemInfoService查询**
```java
// CloudSystemInfoService.getCloudClusterIdByName()
public String getCloudClusterIdByName(String clusterName) {
    String physicalClusterName = getPhysicalCluster(clusterName);
    return clusterNameToId.getOrDefault(physicalClusterName, "");
}

// CloudSystemInfoService.getBackendsByClusterId()
public List<Backend> getBackendsByClusterId(final String clusterId) {
    String clusterName = getClusterNameByClusterId(clusterId);
    String physicalClusterName = getPhysicalCluster(clusterName);
    String physicalClusterId = getCloudClusterIdByName(physicalClusterName);
    
    return new ArrayList<>(
        clusterIdToBackend.getOrDefault(physicalClusterId, new ArrayList<>()));
}
```

---

### 5. 数据写入调用链（存算分离模式）

#### 5.1 完整调用链路

```
INSERT/LOAD 语句
    ↓
生成执行计划
    ↓
选择计算组（ComputeGroup）
    ↓
选择BE（从ComputeGroup的BE列表中选择）
    ↓
BE接收数据
    ↓
BE写入对象存储（StorageVault）
    ↓
更新元数据（Tablet版本等）
```

#### 5.2 关键代码调用链

**步骤1：选择BE进行写入**
```java
// OlapTable.selectBackendIdsForReplicaCreation()
ComputeGroup computeGroup = context.getComputeGroupSafely();
List<Backend> candidateBackends = computeGroup.getBackendList();

// 使用策略选择BE
BeSelectionPolicy policy = new BeSelectionPolicy.Builder()
    .needScheduleAvailable()
    .addTags(Sets.newHashSet(tag))
    .build();

List<Long> beIds = selectBackendIdsByPolicy(policy, replicaNum);
```

**步骤2：BE写入对象存储**
```java
// BE端：接收数据后写入对象存储
// 数据路径：StorageVault配置的路径 + Tablet路径
String storagePath = storageVault.getPath() + "/" + tabletPath;
// 写入对象存储
writeToObjectStorage(storagePath, data);
```

---

### 6. BE端数据读取调用链（存算分离模式）

#### 6.1 完整调用链路

```
BE接收TScanRangeLocations
    ↓
SegmentScanner初始化
    ↓
获取Tablet路径（指向对象存储）
    ↓
创建RemoteFileReader（HDFS/S3）
    ↓
通过FileSystemCache获取文件系统客户端
    ↓
从对象存储读取Segment数据
    ↓
数据解码和返回
```

#### 6.2 关键调用说明

**BE端存储读取流程**：

1. **接收扫描范围**：BE收到FE发送的`TScanRangeLocations`，包含Tablet ID和版本信息

2. **获取存储路径**：
   - Tablet路径存储在元数据中，指向对象存储位置
   - 路径格式：`{StorageVault路径}/{Tablet路径}`

3. **文件系统访问**：
   - 使用`RemoteFileSystem`接口访问远程存储
   - 支持HDFS和S3两种存储后端
   - 通过`FileSystemCache`缓存文件系统客户端，提高性能

4. **数据读取**：
   - 使用`RemoteFileReader`读取Segment文件
   - 支持随机读取和顺序读取
   - 自动处理网络重试和错误恢复

#### 6.3 FE端存储配置调用链

```java
// 文件：fe-core/src/main/java/org/apache/doris/catalog/StorageVault.java
// 存储仓库管理
public class StorageVault {
    // 获取存储路径
    public String getPath();
    
    // 获取存储类型（HDFS/S3）
    public StorageBackend.StorageType getStorageType();
}

// 文件：fe-core/src/main/java/org/apache/doris/fs/remote/dfs/DFSFileSystem.java
// HDFS文件系统实现
public class DFSFileSystem extends RemoteFileSystem {
    @Override
    public Status openReader(String remoteFilePath) {
        // 打开远程文件读取流
        FSDataInputStream fsDataInputStream = hdfsClient.open(inputFilePath, READ_BUFFER_SIZE);
        return Status.OK;
    }
}
```

---

### 7. 调用链关键点总结

#### 7.1 查询调用链核心路径

```
SQL查询
  → OlapScanNode.addScanRangeLocations()  [OlapScanNode.java:441]
  → Tablet.getQueryableReplicas()         [Tablet.java]
  → CloudReplica.getBackendId()           [CloudReplica.java:160] ⭐ 核心入口
  → CloudReplica.getBackendIdImpl()       [CloudReplica.java:297] ⭐ 核心逻辑
  → CloudReplica.hashReplicaToBe()        [CloudReplica.java:408] ⭐ Hash算法
  → CloudSystemInfoService.getBackendsByClusterId() [CloudSystemInfoService.java]
  → 返回Backend ID
  → 构建TScanRangeLocation
  → 发送到BE执行
```

**关键调用点说明**：

1. **`CloudReplica.getBackendId()`**（行160）：查询时的核心入口，每次查询都会调用
2. **`CloudReplica.getBackendIdImpl()`**（行297）：BE选择的完整逻辑，包含多种场景处理
3. **`CloudReplica.hashReplicaToBe()`**（行408）：Hash算法选择BE，保证负载均衡

#### 7.2 Tablet创建调用链核心路径

```
CREATE TABLE
  → CloudInternalCatalog.createCloudTablets()  [CloudInternalCatalog.java]
  → new CloudReplica(replicaId, null, ...)     [CloudReplica.java:87] ⭐ backendId=null
  → super(replicaId, -1, ...)                  [Replica.java] ⭐ 父类backendId=-1
  → Tablet.addReplica()                        [Tablet.java]
```

**关键差异点**：

- **存算一体**：创建时`backendId`必须指定，Tablet与BE强绑定
- **存算分离**：创建时`backendId=null`，调用父类时传入`-1`，表示未绑定任何BE

#### 7.3 重平衡调用链核心路径

```
定时任务触发
  → CloudTabletRebalancer.runAfterCatalogReady()  [CloudTabletRebalancer.java]
  → statisticsBeToTablets()                       [统计BE-Tablet映射]
  → balancePartitionLevel() / balanceTableLevel() / balanceGlobal()
  → updateTabletMapping()                         [更新映射关系]
  → CloudReplica.updateClusterToPrimaryBe()       [CloudReplica.java:575] ⭐ 更新映射
```

#### 7.4 多副本模式调用链

```
查询时
  → CloudReplica.getBackendIdImpl()              [CloudReplica.java:297]
  → Config.enable_cloud_multi_replica == true
  → hashReplicaToBes(clusterId, false, replicaNum) [CloudReplica.java:469] ⭐ 多BE选择
  → 返回多个BE ID列表
  → 随机选择一个BE进行查询
```

**多副本优势**：
- 提高查询并发能力
- 支持冷热读分离（通过`cloud_cold_read_percent`配置）
- 更好的容错能力

---

## 数据流程

### 1. 查询流程

```
┌─────────┐
│  Client │
└────┬────┘
     │ SQL查询
     ↓
┌─────────────────┐
│   FE: 解析SQL   │
│  生成执行计划   │
└────┬────────────┘
     │
     ↓
┌─────────────────┐
│ OlapScanNode    │
│ 获取ComputeGroup │
└────┬────────────┘
     │
     ↓
┌─────────────────┐
│ CloudReplica    │
│ getBackendId()  │
│ 动态映射BE      │
└────┬────────────┘
     │
     ↓
┌─────────────────┐
│ 构建ScanRange   │
│ 发送到BE        │
└────┬────────────┘
     │
     ↓
┌─────────────────┐
│   BE: 接收请求  │
│  从对象存储读取 │
└────┬────────────┘
     │
     ↓
┌─────────────────┐
│  对象存储       │
│  (S3/HDFS)      │
└─────────────────┘
```

### 2. 写入流程

```
┌─────────┐
│  Client │
└────┬────┘
     │ INSERT/LOAD
     ↓
┌─────────────────┐
│   FE: 选择BE    │
│  从ComputeGroup  │
└────┬────────────┘
     │
     ↓
┌─────────────────┐
│   BE: 接收数据  │
│  写入对象存储   │
└────┬────────────┘
     │
     ↓
┌─────────────────┐
│  对象存储       │
│  (S3/HDFS)      │
└─────────────────┘
```

### 3. Tablet重平衡流程

```
┌─────────────────────┐
│ CloudTabletRebalancer│
│ 定时任务触发        │
└────┬────────────────┘
     │
     ↓
┌─────────────────────┐
│ 统计BE-Tablet映射   │
│ 计算平衡度          │
└────┬────────────────┘
     │
     ↓
┌─────────────────────┐
│ 选择迁移Tablet      │
│ 更新CloudReplica映射│
└────┬────────────────┘
     │
     ↓
┌─────────────────────┐
│ 发送预热任务(可选)  │
│ 等待预热完成        │
└────┬────────────────┘
     │
     ↓
┌─────────────────────┐
│ 更新元数据          │
│ 完成迁移            │
└─────────────────────┘
```

---

## 配置说明

### 关键配置项

#### 1. 存算分离模式开关
```properties
# 是否启用云模式（存算分离）
cloud_mode = true
```

#### 2. 计算组预热策略
```properties
# 所有Compute group的扩缩容预热方式
# 可选值：without_warmup, async_warmup, sync_warmup
cloud_warm_up_for_rebalance_type = async_warmup

# 预热任务超时时间（秒）
cloud_pre_heating_time_limit_sec = 300
```

#### 3. BE分配策略
```properties
# 当tablet分布的be异常时，是否立即映射tablet到新的be上
enable_immediate_be_assign = false

# 一个BE挂掉多长时间后，它的tablet彻底转移到其他BE上（秒）
rehash_tablet_after_be_dead_seconds = 3600
```

#### 4. 多副本模式
```properties
# 是否启用多副本模式
enable_cloud_multi_replica = false

# 多副本数量
cloud_replica_num = 3

# 冷读百分比（0-100）
cloud_cold_read_percent = 10
```

#### 5. 重平衡配置
```properties
# Tablet重平衡间隔（秒）
cloud_tablet_rebalancer_interval_second = 600
```

#### 6. 自动启停
```properties
# 是否启用自动启停功能
enable_auto_start_compute_group = true

# 自动启停等待cluster唤醒退避重试次数
auto_start_compute_group_retry_times = 300
```

---

## 关键设计点

### 1. 动态映射 vs 固定绑定

**存算一体模式**：
- Tablet创建时固定绑定到BE
- BE故障需要数据迁移
- 扩缩容复杂

**存算分离模式**：
- Tablet创建时不绑定BE（backendId = -1）
- 查询时动态映射到BE
- BE故障只需更新映射关系，无需数据迁移

### 2. 多级平衡策略

1. **分区级平衡**：优先保证分区内Tablet分布均匀
2. **表级平衡**：分区级平衡后，进行表级平衡
3. **全局平衡**：最后进行全局平衡

### 3. 预热策略

- **without_warmup**：不预热，直接迁移
- **async_warmup**：异步预热，不阻塞迁移
- **sync_warmup**：同步预热，等待预热完成

### 4. 主备映射机制

- **primaryClusterToBackends**：主映射，查询时优先使用
- **secondaryClusterToBackends**：备用映射，主映射不可用时使用
- **memClusterToBackends**：多副本模式的内存映射

---

## 总结

存算分离架构通过以下核心机制实现存储和计算的解耦：

1. **动态映射**：Tablet不固定绑定BE，查询时动态选择
2. **计算组管理**：通过ComputeGroup组织计算资源
3. **存储抽象**：通过StorageVault统一管理存储后端
4. **智能平衡**：通过CloudTabletRebalancer实现负载均衡
5. **弹性扩缩容**：计算节点可独立扩缩容，无需数据迁移

这种架构实现了：
- ✅ 计算和存储独立扩展
- ✅ 成本优化（计算节点可自动启停）
- ✅ 高可用（BE故障不影响数据）
- ✅ 资源隔离（不同ComputeGroup隔离）

---

## 参考代码位置

- ComputeGroup: `fe-core/src/main/java/org/apache/doris/cloud/catalog/ComputeGroup.java`
- CloudReplica: `fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudReplica.java`
- CloudTabletRebalancer: `fe-core/src/main/java/org/apache/doris/cloud/catalog/CloudTabletRebalancer.java`
- CloudSystemInfoService: `fe-core/src/main/java/org/apache/doris/cloud/system/CloudSystemInfoService.java`
- StorageVault: `fe-core/src/main/java/org/apache/doris/catalog/StorageVault.java`
- OlapScanNode: `fe-core/src/main/java/org/apache/doris/planner/OlapScanNode.java`
- CloudInternalCatalog: `fe-core/src/main/java/org/apache/doris/cloud/datasource/CloudInternalCatalog.java`

---

## 调用链快速参考表

### 核心方法调用关系

| 场景 | 入口方法 | 核心方法 | 文件位置 | 关键行号 |
|------|---------|---------|---------|---------|
| **查询时BE选择** | `OlapScanNode.addScanRangeLocations()` | `CloudReplica.getBackendId()` | OlapScanNode.java | 441-658 |
| **动态BE映射** | `CloudReplica.getBackendId()` | `CloudReplica.getBackendIdImpl()` | CloudReplica.java | 160, 297 |
| **Hash选择BE** | `CloudReplica.getBackendIdImpl()` | `CloudReplica.hashReplicaToBe()` | CloudReplica.java | 408 |
| **获取计算组BE列表** | `CloudReplica.hashReplicaToBe()` | `CloudSystemInfoService.getBackendsByClusterId()` | CloudSystemInfoService.java | - |
| **Tablet创建** | `CloudInternalCatalog.createCloudTablets()` | `new CloudReplica()` | CloudInternalCatalog.java | - |
| **Tablet重平衡** | `CloudTabletRebalancer.runAfterCatalogReady()` | `CloudReplica.updateClusterToPrimaryBe()` | CloudTabletRebalancer.java | - |
| **更新BE映射** | `CloudTabletRebalancer.updateTabletMapping()` | `CloudReplica.updateClusterToPrimaryBe()` | CloudReplica.java | 575 |

### 关键数据结构

| 数据结构 | 作用 | 定义位置 |
|---------|------|---------|
| `primaryClusterToBackends` | 主计算组到BE的映射 | CloudReplica.java:57 |
| `secondaryClusterToBackends` | 备用BE映射（延迟分配） | CloudReplica.java:74 |
| `memClusterToBackends` | 多副本模式的内存映射 | CloudReplica.java:71 |
| `clusterIdToBackend` | 计算组ID到BE列表的映射 | CloudSystemInfoService.java |

### 配置参数影响

| 配置参数 | 影响的调用链 | 说明 |
|---------|------------|------|
| `enable_cloud_multi_replica` | `getBackendIdImpl()` → `hashReplicaToBes()` | 启用多副本模式 |
| `enable_immediate_be_assign` | `getBackendIdImpl()` → `updateClusterToPrimaryBe()` vs `updateClusterToSecondaryBe()` | 控制BE分配策略 |
| `cloud_cold_read_percent` | `getBackendIdImpl()` 多副本选择逻辑 | 控制冷读百分比 |
| `cloud_warm_up_for_rebalance_type` | `CloudTabletRebalancer` 预热策略 | 控制预热方式 |

---

## 调试建议

### 1. 查询BE选择问题

如果查询时BE选择异常，可以追踪以下调用链：

```bash
# 1. 检查OlapScanNode的addScanRangeLocations方法
# 查看是否正确获取了ComputeGroup

# 2. 检查CloudReplica.getBackendId()的返回值
# 查看是否抛出ComputeGroupException

# 3. 检查CloudReplica.getBackendIdImpl()的执行路径
# 查看走了哪个分支（多副本/单副本/Colocate）

# 4. 检查CloudSystemInfoService.getBackendsByClusterId()
# 查看计算组是否包含可用的BE
```

### 2. Tablet映射问题

如果Tablet映射异常，可以检查：

```bash
# 1. 查看CloudReplica的primaryClusterToBackends
# 确认是否有正确的BE映射

# 2. 检查CloudTabletRebalancer的平衡逻辑
# 确认重平衡是否正常工作

# 3. 查看BE状态
# 确认映射的BE是否可用
```

### 3. 性能优化建议

- **合理配置预热策略**：根据业务需求选择`without_warmup`、`async_warmup`或`sync_warmup`
- **启用多副本模式**：对于高并发场景，启用`enable_cloud_multi_replica`
- **优化Hash算法**：确保Tablet分布均匀，避免热点BE
- **监控重平衡**：定期检查Tablet分布是否均衡


